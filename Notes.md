# DSA_Question Notes

# Introduction of the Linked List.

- // Linked List is linear data structure 
// It's a dynamic data structure  
// we connect each data with a chain .
// I'ts chain is link to attached each data 
// It's store the data in a heap memory
// NUll is reperesent null.
// In java we store reference variable . Reference variable point to object. and object is node 
// First value to store in Node class  is data  
// Next variable ka type node hi hoga .kyu ki node point karta hai object ko 

// Every single data two parts
// 1. which type of data can be store
// 2. next is reference . it's a pointer to point the next node 
- In doubly linked list we pointing to the back but in single linked list cann't do.
- in the linked list next is pointing to the next node.


# Stack
- TOP :- This structure is use for access the topest element.
- pop :- This structure is use for empty the stack.
- push :- push is used to insert the data into the stack


static_cast<long long>(mid*mid);

map<Node*,int>mpp;


# Tortise and horse 
Node* slow=head;
Node* fast=head;
slow increase by one .
fast increase by two.

# Put data in hashmap.
mpp.put({temp,1});


# Strings
# s.isEmpty() check the string is null or not.

# Trim Method
Trim any leading or trailing spaces
        s = s.trim();


# codPointAt(0).
Str.codePointAt(0) Return the Unicode of the first character in a string (the Unicode value of "H" is 72):

# Java String codePointBefore() Method
Definition and Usage
The codePointBefore() method returns the Unicode value of the character before the specified index in a string.

The index of the first character is 1, the second character is 2, and so on.

Note: The value 0 will generate an error, as this is a negative number (out of reach).

# Delete Node in a linkedlist
after delete the node in c++ make sure free of the node otherwise still in the memory.

In java the garbage collection take place and deleted 

# static use because we directly access in the main method


# String convert to number.
int num = Integer.parseInt(String s);

# Math.pow(x,n);
Find easily square


# In the comparison part, left.data != right.data needs to be handled carefully for reference comparison (== vs .equals()).


# 
The logic remains the same, but since Javaâ€™s boolean type expects an explicit comparison, we check if ((n >> k) & 1) is equal to 1.


# Stack
stack using arraylist.

